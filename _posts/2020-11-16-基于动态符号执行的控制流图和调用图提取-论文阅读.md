---
layout:     post
title:      基于动态符号执行的CFG和CG提取 论文阅读
subtitle:   电子科技大学的一篇硕士论文 个人向笔记
date:       2020-11-16
author:     Rigel
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - 符号执行 - 控制流程图
---

# 基于动态符号执行的控制流图和调用图提取

## 0x00 绪论

### 背景

对于二进制的程序分析来说，控制 流图和调用图的提取是很重要的一个环节，因为控制流图和调用流图能表示一个 程序的基本结构和调用关系，能为后续的程序分析提供很大的便利。

基于当前先进的 Angr 平台，本文开发出来了一套控制流图和调用图提取的系统。当前的系统采用了**动态符号执行**的技术，能够**完成中间语言的转化，程序的控制流和调用流的提取**。

然后为了缓解动态符号执行中路径指数增长造成的时间消耗，同时也是**为了缓解动态符号执行过程中的路径爆炸问题**，本文提出了**多进程共同探索的路径探索算法**，基于当前的 CPU 多核心的特性，在充分利用计算机的计算资源的前提下， 对路径探索的时间进行优化。



程序的**控制流图(Control Flow Graph, CFG)**，是**描述一个程序的所有可能的运行的过程**，他是由编译器在内部维护的。**在一个程序的控制流图中，程序的所有的路径都被包含在内**。控制流图中每个块也就是图中每一个点，代表着**基本块**（Basic Block），**在基本块内是不发生任何的转移和跳转的，所以在一个块中的代码要么全部执行，要么不执行**。然后在块和块之间存在跳转的话用一条定向的边缘来表示块之间的跳转。在跳转中可能会存在选择性跳转（je、jz 等），当然也有一些无条件的跳转（jmp、ret、call 等）。

**调用图(Call Graph, CG)**表示程序中的函数之间的相互调用关系。**每个节点表示一个函数**，一个函数中可能存在多个基本块，当有调用存在 的情况下，即两个函数之间存在调用关系的时候，用有向边缘来表示。调用图的话可以理解为把控制流图进行压缩从而**只显示出其中的调用关系（call）**，他包含了程序执行过程中**所有可能发生的调用关系**。



应用：

- 所以对于恶意软件检测过程中，只需要找到恶意软件一些基本模式就可以通过控制流图比对找出类似的恶意软件。

![image-20201224105112827](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224105112827.png)

- 程序的分类和聚类分析

![image-20201223170917102](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201223170917102.png)



- 控制流图同时还可以用来检测程序中的漏洞问题，比如是否存在重写、堆溢出、栈溢出、doublefree 等常见的漏洞。通过控制流图的构建可以得到程序的整个架构。通过 CFI [12-14]（控制流完整性）来判断程序实际执行的过程中是否按照控制 流图中的方向进行。这样就可以完成一些基础漏洞的检测和排查，当找到不符合控制流图中规定跳转的位置，就是程序漏洞的具体位置。现在的**CFI 检测**需要用到相应的**插桩**技术，即**在所有的跳转点打入标记，然后在程序动态运行的详细过程中截取执行流，判断跳转点位置是否遵循 CFI**。                 [CFI/CFG 安全防护原理详解](https://blog.csdn.net/pwl999/article/details/111395670)



符号执行是指在分析过程中符号量代替真实值地对程序进行探索，然后执行 过程中路径变成了符号表达式。然后再用求解器进行求解，最后来判断路径是否可达。这样可以避免大量的输入进行相同路径探索的情况。

但当前的动态符号执行不可避免的存在路径爆炸问题，随着程序中分支和循环不断的增多，路径数量急速的增长，为了判断路径的可达性，进行求解的部分也呈指数形式的增长，所需要的资源也急速的增长，这就是路径爆炸问题。而且如今，在路径爆炸问题上还没有完美的解决方案。在本文中提到的并行探索的算法也只是起到一定的缓解作用。根据当前计算机多核 CPU[21-22]特性，提出了多进程共同探索的方式提高运行速度。该算法主要包括**状态封装**和**进程之间传输**以及**封装状态的恢复**三个部分，能在保证内存占用基本不变的基础上提高效率。



### 国内外研究现状

静态分析就是不去真实的执行程序，一般是对代码进行分析，可以是对源代码，当然也可以是二进制代码，对于二进制代码，通过反汇编就可以进行得到其汇编语言。因为不需要真实的运行程序，所以时间和资源消耗上较少，但其检测的力度也有一定的削弱。

程序动态分析(Program Dynamic Analysis) [24-26]是**在给入程序真实输入前提下， 让程序去运行**，在运行过程中检测过程中的信息是否符合安全和规范，是否存在问题与漏洞。动态分析与静态分析相比较来说，动态分析是会去实际的运行程序， 所以其执行速度和效率都比较慢，但是在误报率上面比较低。

当前的控制流图生 成工具大致也可以分为，通过静态分析[27-28]产生程序的控制流图和通过动态工具产生程序的控制流图。

- IDA	由于IDA采用静态分析的原因，导致间接控制流和调用流会断掉。所以对于混淆的程序和一些存在重写攻击的程序，他是检测不到的，但IDA的执行速度相对来说是比较快的。

- 暴力执行工具	大多都采用动态插桩的方式强制执行程序，系统通过一系列指令**强行更改可能影响到路径增加的位置，例如：跳转表，谓词**，而不去管他们被计算成如何的值，当需要输入的时候，工具会随机的产生数值，因此强制执行可以探索更多的程序路径。因为暴力执行不需要每次产生具体的值，所以在运行的时间上面会有所减少。因为他不关注输入和运行过程，只关注运行过程中判断条件的变化，所以这种方法**无法判断路径的可达性**，也就是说在产生的控制流图和调用图中可能存在不可达的状态。

- Fuzzing	当前的大多fuzzing框架如图 1-3 所示。![image-20201224112908090](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224112908090.png) 

  Fuzzing在漏洞挖掘[32-34]方面被应用的很多，但由于fuzzing往往给的多个输入都走了相同的路径，所以他的探索过程中代码覆盖率并不高。为了能够探索到尽量多的路径，符号执行的概念被提出，理论上来说符号执行可以探索到程序存在的所有路径。



符号执行是分为**动态符号执行**[35]和**静态符号执行**[36]的。

- 静态符号执行传统的来说，就是**把所有需要用户输入的地方全部变成符号值，然后再模拟程序运行，这样每一条路径就变成了相应的符号的表达式**，对于符号的表达式，求解器会进行相应的求解，然后判断当前的路径可达性， 但是由于仍然属于静态分析的范围，所以符号执行仍然存在一定的局限性。
- 在动态符号执行中， 程序首先会给出随机的一组值运行程序，在运行的过程中，也加入相应的符号量， 同时会不断收集程序的约束，**当路径运行完成后，改变任意一个约束路径的表达情况，然后将新的约束集合进行求解，求解的值再次用于下次的探索，不停的变换约束，直到无法探索到新的路径为止。** 	类似于fuzzing的变异，思想一致



动态符号执行对于CFG和CG的提取是有很大的优势的:

- 首先是对于路径的探索上面，因为符号值的引入，每一条路径都变成了符号表达式的集合，所以其可以表示多个输入，对路径的探索更具有针对性。          现在也有引入符号执行的hybrid fuzzer，去求解输入如何变异才能触发新路径
- 其次是在路径的可达性上面，因为**有求解器的验证，所以当前的路径是可达的**，因为关注探索过程中的符号量的变化，即符号传播，所以动态符号执行不会像暴力执行那样产生许多的不可达路径和状态。
- 当前的静态分析工具因为没有真实的运行程序，甚至没有模拟的去执行程序，所以在程序的间接跳转位置都不会识别到，这样就会缺少很多的路径，而**动态符号执行的过程中因为有真实的输入和执行，所以在提取上会有更多的路径被探索到**。



动态符号执行的过程中一些不可避免的问题：

- 首先是求解器的问题	当前的求解器很依赖于计算机资源，同时对于浮点数的求解一些求解器是不可以满足的， 所以这就很大程度上限制了符号执行的发展，因为在有些地方求解器是求解不出来的，但这并不能说明是不可达路径。这个问题主要是由于求解器的计算能力所限制的。
- 其次是当前的动态符号执行过程中会遇到很多的函数库，如果每一个库都深入的去执行会造成很大的问题，比如说内存分配的函数malloc，其实只需要对相应大小的空间进行符号化即可，而不需要真实的去深入执行函数库里面的函数。所以**在Angr平台的当前实现中会将这些函数进行语意分析，然后重构一遍，当需要运行到这些函数的时候会截获运行流，然后运行重新构造的函数。**
- 最后是当前动态符号执行过程中的时间和内存消耗问题。由于探索过程中探索的层次的深入而导致当前路径迅速增长，从而产生路径爆炸问题。



在二进制程序的控制流图和调用图的提取中有许多的可行方法，但是都有一定的优缺点，所以本文力求一种路径覆盖率比较高，同时执行速度尽量快的方法 来提取程序的控制流图和调用图。研究的内容主要包含以下三点： 

1.在当前符号执行引擎 Angr 的基础上，开发一套基于动态符号执行的工具用于控制流图和调用图的提取，需要完成**汇编语言到中间语言的转化**，同时**对程序的控制流和调用流进行提取**。 

2.基于当前的 CPU 的多核特性，设计一种多进程共同探索的缓解路径爆炸的思 路。同时为了保证效率和减少多进程探索中内存的消耗，设计一种分派算法在提 高效率的同时不增加内存负担。 

3.与现今所存在的主流的控制流图和调用图提取方式进行比较，并且展开测试，通过对比来体现本文所开发的控制流图和调用图提取工具的优势以及本文所提出的时间优化算法的优越性。



## 0x01 CFG和CG提取相关技术研究

这里更加详细地论述当前存在的主流工具，同时详细描述本文所要应用到的动态符号执行技术。

### 主流工具

#### ida

IDA Pro 是一个交互式的，可编程，可扩展的多处理器分析工具，还可以**交叉多个平台**来分析程序。IDA 是一个基于**递归下降的反汇编**[41]的形式。

>[反汇编算法介绍和应用——线性扫描算法分析](https://blog.csdn.net/breaksoftware/article/details/7893422)
>
>[反汇编算法介绍和应用——递归下降算法分析](https://blog.csdn.net/breaksoftware/article/details/7893871)
>
>windbg使用的线性扫描一个很大的缺点是：因为其不知道程序执行流而导致将数据识别为代码。
>
>递归下降算法一个主要的思路就是源于模拟CPU执行从而得知哪些是指令，需要执行。但是我们反汇编是静态的，而CPU执行指令是动态的，静态分析无法得知动态执行的结果，这个严重的缺陷会导致我们想完全模拟CPU执行去反汇编的思路变得不现实。   如果我们jmp eax了而不知eax是啥时，或者**call、ret不知跳转地址时，本次递归下降都会结束，并在延时反汇编列表中寻找新的起始反汇编地址**。          缺点：可能无法覆盖全部代码

IDA 为静态分析软件，所以他在很大的程度上不能满足准确性，而且在二进制程序的间接跳转[42]位置他是不能进行识别的，此外函数的调用关系也是不能解析出来的。但**静态分析效率高，速度快**，所以在漏洞检测和程序分析[43] 上还是得到了广泛的应用。



#### 暴力执行工具 X-Force

由于在程序的执行过程中程序**路径的走向往往与约束的判断相关联**，所以改变相应的约束条件就会走相反的路径，**暴力执行就是通过改变分支的判断结果，来改变程序的走向的**。

在强制执行开始时，程序给定一个随机的输入，这个随机的输入只是为了让程序正常执行下去，而不是驱动程序执行不同的路径。



#### 符号执行工具 KLEE

KLEE是一款开源的基于符号执行的自动软件测试工具，基于LLVM编译底层基础，能够自动生成测试样例检测软件缺陷。

通过插入函数对内存参数进行相应的符号化，然后在符号值的执行过程中跟踪符 号化的内存，如果有其他的内存空间与当前符号化的空间进行交互，那么也会对 相应的内存进行符号化，在遇到分支的情况下，KLEE 会对两条路径上面的约束条 件使用 STP [47]进行求解。判断两条路径上的约束是否有解，即判断路径可达性， 可达的情况下分别对两条路径进行探索。

>**符号执行传统的意义上来说是属于静态分析的范畴**，因为在运行的过程中， **只是将输入符号化，然后在运行的过程中符号随着变量的传递而传递，改变而改变，当收集到当前的路径约束后，利用求解器对当前的符号表达式进行求解，有解则说明当前的路径可达，将继续往下进行探索，当无解的情况下，则该条路径探索结束**。所以可以看到符号执行是**没有真实的执行程序的，他只是判断当前路径的约束条件的集合是不是有解**。在遇到标准库的函数调用的情况下，KLEE 会将相应的代码编译成 LLVM IR，然后再进行解析。
>
>**动态符号执行也可以叫做混合执行**，其探索思路是首先需要一个具体的实际输入的值，然后在探索的过程中符号值和实际值同时进行探索，**在探索结束时收集当前路径上的约束，然后对约束进行变换后，送入求解器进行求解，然后得到新的值来进行上述重复的探索**，当然后续的输入依赖前面的输入所探索收集到的约束。       行为模式上与fuzz相似

KLEE与传统的符号执行很相似，当前的KLEE 的主要包含几个比较重要部分，首先**第一个部分是将对应的汇编语言转化为中间语言**，这样他能够更好的去解读程序，第二个部分是**内存建模，主要用于变量的符号化**，他给能给符号值一段指定的大小的空间。最后是**约束收集**的部分，主要负责去**对符号量的交互过的 内存空间进行标记，同时需要对约束的条件集合进行收集，然后将结果传递给求解器**，来判断路径的可达性。最后的部分就是相应的求解部分，如果求解有解则继续探索，无解则结束。

由于 KLEE 存在比较多的问题，所以在不断的改进中，其团队开发了 S2E.S2E 比 KLEE 更具有优势性，尤其体现在他将符号执行的引擎迁移到了虚拟机当中。

![image-20201224173612795](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224173612795.png)



#### 符号执行工具 Angr

符号执行工具Angr是当前一个很出色的**二进制的分析平台**，其主要用的技术是**动态的符号执行**技术。Angr 在路径探索、控制流的提取方面都有很出色的表现，本文所涉及到的符号执行工具的大部分内容也借鉴了 angr 的模块。

angr有**自己的中间语言 VEX**，并将这种中间语言与 Python 的 开发进行了结合，屏蔽了指令集的差异，使得 Angr 具有良好的兼容性，能够在各 个平台中发挥自己的出色的功能和特长。

Angr 有很多的 API 可以供后续的开发者开发和使用，所以也大大的方便了人们在平台上面进行二次的开发。

在 angr 分析程序的过程中，当**遇到相应的库函数的时候**，angr 首先会**利用当前的函数名进行识别**，当识别到库中的函数的时候，Angr 会**利用 Hook 的技术，对当前的进程进行劫持，使得不会真实的去执行库中的函数，而是会执行相应的利用 Python 实现的相同功能的函数**。   【在Android中，一般是通过ptrace函数附加进程，然后向进程注入so库，修改其内存中的进程代码，替换其过程表的符号地址。 [blog链接](https://blog.csdn.net/jsqfengbao/article/details/52217574?utm_source=blogxgwz5)】

![image-20201224180753021](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224180753021.png)

首先 Angr 会将汇编代码转化成VEX，这样的话可以方便进行语义的分析，然后会运用符号执行的方式进行路径的探索以及路径的统一管理，然后**在路径的探索过程中，系统会将 *每个* 分支处的约束表达送入求解器进行求解，求解的过程返送回系统，告知其是否可达**，最后在所有路径探索完成后返回生成的信息和结果。



### 动态符号执行架构

#### 整体框架

在**每个分支**的位置，程序会将当前的符号表达式送入求解器进行求解，如果没有解的话就表示当前的路径不可达。    **每遇到一个分支约束，先去求解，判断是否可达，再深入下去，从而才不会执行deadcode。**

![image-20201224183118388](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224183118388.png)

源代码第 6 行代码的位置是不能走的到的，这个位置也就是代码中的deadcode。当前程序的路径总共是 2 条。

![image-20201224183300521](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224183300521.png)

**首先**动态符号执行的引擎会**利用随机的数值运行当前的程序**，在运行的过程中，也有相应的符号化变量加入，所以**利用动态插桩的技术就可以得到给定输入路径上的所有约束集合**，然后对于其中的一个约束进行**求逆**后产生**新**的约束集合，**如果当前约束集合求解后有解，就把求解的值作为输入进行探索(这时就是通过变换约束得到的新路径)**，不断重复上述的过程，直到探索完所有路径。

​	【之所以一次只对一个约束求逆，是因为这个约束改变后，在后面的约束有可能就不在新路径上了，所以求逆了不能保证一定有用。  所以优先对后面的约束求逆，依次往上。】

>​	（我理解的路径还是指一个基本块到另一个基本块，并不是一连串的基本块序列。因为我们的目标就是执行所有会执行到的代码）。 
>
>​	另外，一次执行不可能涉及到所有的约束分支，新路径上有可能会发现新的约束分支。但当前从程序开始运行起遇到的所有约束（在不同路径序列上）都求过逆后，那么就说明**所有路径序列**（从程序运行开始）上没新路径了，也即整个程序能运行到的地方都运行了，那么整个路径探索就完成了。
>
>​	一些思考：code coverage只是一个指标，并没有考虑每个基本块执行的时候的上下文状态（如变量的值等），所以就算运行了这个基本块，也不一定能触发该基本块中的bug。 所以理想情况下还是需要一个基本块穷尽所有可能的状态（通过输入），但这很难做到。            这也是fuzz过没有crash的程序不一定就没有洞的原因。



下面通过一段具体的程序具体的来介绍一下动态符号执行的执行流程。程序有三个分支，假设第 8 行的位置存在漏洞。

![image-20201224184725308](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224184725308.png)

到当前的 test 函数有三个参数，分别是 m、n 和 p，所以在动态符号运行中，首先会把当前的三个变量进行符号化，假设当前的 三个变量符号化为了 M，N，P。然后同时需要给入实际的值，假设为（2，3，5）， 当运行到程序第 3 行的位置，不满足当前的 m=1 的条件，所以跳过第 4 行代码， 在第 5 行，第 7 行同样不满足条件，所以**探索的相应的路径**可以大概表示为 (1→2→3→5→7→9)，因为对于三个判断条件都不满足，所以约束的集合可以表示成： ```<M!=1'>∩<N!=2>∩<P!=3>```

此时，需要对当前约束的集合中的一个约束进行求逆，比如说此时正好将 < P!=3>变换为<P ==3>，然后再对当前的约束表达式进行求解，就可以得到新的输入组合（2，3，3），然后在测试的过程中我们就会发现在第 3 行和第 5 行的位置仍然不满足条件，所以会跳过相应的第 4 和第 6 行的代码，但在第 7 行的位置， 他刚好可以满足条件，所以将运行第 8 行的代码，最后根据新的测试用例我们可以得到全新的路径（1→2→3→5→7→8→9），然后这条路径刚好探索到有问题的位置（bug 函数），但由于当前并没有对所有的程序路径进行探索，所以还需要对约束进行变换重复上述过程。最后完成所有路径的覆盖。

​	**所以动态符号执行的变异就是对约束序列中的某个约束（一个约束对应一个分支）进行取逆，如果取逆后的新约束序列有解，那么说明有新路径，下次就去执行这条路径。**



![image-20201224212016594](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224212016594.png)

假设我 们当前给入一组输入，其探索路径如图（a）所示，所以收集到的约束为¬π1 ∧ ¬π2 然后探索到的路径为 φ1→φ2→φ3，这里的每个φ1，φ2，φ3 代表程序的基本块，同时为了发现所有的路径我们需要维护一个工作的列表 T。在第一次探索结束后我们会变换图（a）路径中的一个约束条件产生新的约束 集合¬π1 ∧ π2，并把该约束集合求解过程加入到 T 中，经过求解后发现有解，产 生输入 M，继续向下探索，探索到新的路径φ1→φ2→φ4 如图（b），最后再将¬π1 的求解加入 T，探索到如图（c）中的新路径φ1→φ4。



#### 符号传播

在符号执行的过程中，那些**需要人为输入的量都被符号化成了相关的符号量**，包括键盘的键入信息，读取文件的信息、或者是内存分配信息等。

符号传播的意思就是说在我们运行过程中因为符号量代替了实际值作为了输入，那么在运算的过程中比如说我们遇到一个加法的操作，那么此时就不再是对于值进行相加， 而是将符号值相加的量作为一个值传递给和。在实际操作的过程中其实是将对应内存地址的数据进行变化。

符号传播主要作用是建立符号变量传播的关系，并且更新映射的关系。

二进制的程序分析现在主要是将二进制的代码转化成相应的汇编语言，但在汇编中大量的逻辑结构很复杂，这也给分析中带来了很大的困难。当然这个也是符号执行中存在的问题。



#### 路径爆炸

动态符号执行在小程序上具有良好的实用性，但是在大程序的分析过程中没有很好的分析效果，主要是由于当前的符号执行存在着路径爆炸问题。

**路径爆炸问题就是在随着程序的探索，程序中的分支语句会导致程序的探索路径呈现指数级的增长，这样就会增加计算机运行时候的负担，不管是在内存或者在时间上面，甚至于可能会导致当前的分析的崩溃。**

下图大概表示了一个程序的分支的 急速增加，程序开始运行有一条路径，然后随着程序的探索，每一条分支也会进行分支，所以每次分支的数量就增加 2 倍，然后随着时间的推移，路径的数量会 增加到 2 的 n 次方。

![image-20201224203732783](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224203732783.png)

当前缓解思路：

- 利用输入划分。输入划分的核心思想是 Flowtest 算法。在符号化的过程中只把一块的输入进行符号化，那其他块的输入就按照实际的输入来继续进行，这样就会让在不降低效率的情况下， 使得当前程序的整个输入长度中的数据完成了符号化。 主要的不足可以分为两点：

  - 变量之间也就是各部分的输入之间的依赖关系可能不会分析的很准确，这就会造成比较大的误差。
  - 这种方法在面对变量之间关联度很高的程序是无效的。

- 利用符号语法。符号语法的思路就是首先对程序进行分析，然后找出不易触发的位置，然后着重解决这个地方的探索，这种设计类似于对关键难点的地方进行分析，而简化对简单易触发位置的探索，所以在一定程度上能缓解路径爆炸问题。

- 利用摘要。摘要的具体实现方法是对于程序中的函数里面所涉及到的每一条路径都会有两个表达式，一个是和输入有关的（基本块入口的分支），另外的一个是和输出有关系的（基本块出口）。前者成为 pre，后者成为last，函数的摘要可以定义为 f = (pre1∩last1 )∪(pre2∩last2 )∪… 。 

  



## 0x02 CFG和CG提取系统的实现

本文借用 Angr 平台开发一套基于动态符号执行的二进制文件控制流图和调用图提取工具并在后面的位置进行一系列的优化。

### 总体设计

首先把**二进制字节码转化为**解析更加容易分析的**中间语言**，在中间语言上进行分析，运用动态符号执行的技术执行程序，**在所有的直接跳转流和间接跳转流的位置进行标记**；同时读取 PE 文件，得出当前所有的系统 API 调用然后进行记录，最终将所有控制流和调用流信息进行图形化。

![image-20201224210844246](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224210844246.png)

动态符号执行的算法流程为：

（1）首先给入输入使得当前程序去执行。

（2） 收集当前路径上面存在的所有的约束。

（3）将约束求反获得新的输入。

（4）重复 1 到 3 的步骤直到得出现在的所有路径。

**符号执行的作用就是找到所有会执行到的路径，包含静态分析得不出的间接跳转（如jmp *%eax）。**



### 中间语言转化

精简指令集在处理高级语言方面有很强的能力，但是随着当前程序的逐渐复杂和增大，因为精简指令集的指令较少，且某一指令的功能也比较单一，所以在大程序中我们会发现，一些取和存之类的指令占据了非常高的一个比例，这会影响时间和准确性。

所以随着集成电路的发展，复杂指令集越来越多的被应用，他结构庞大，处理能力比较好，指令多且灵活，大大的方便了编程的运行速度，但是也存在着一定的缺陷，首先是对硬件的要求变得更高，其次也给程序分析带来了一定得影响。  	   【X86 指令集是复杂指令集，arm是精简指令集】



在程序分析的过程中，过于复杂的指令结构造成了很大的困难。所以在符号执行分析之前一个很重要的部分就是去解析 x86 的语义，把相对难以理解的指令或者说是解析困难的指令架构转换成一种简单的能够理解的指令。这里借助于angr 所开发的 VEX 语言进行了中间语言的转化。

![image-20201224215959797](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201224215959797.png)

第 9 行 IMark 后面表示**当前**的内存地址和他所占的地址长度，第 10 行对应申请变量 a，第 11 行表示 a = 5，第 12 行 的操作 PUT(pc)直接重置了当前的 pc 值。



### 符号化以及约束求解

动态符号执行过程中的符号化和求解过程与符号执行是一样的。

程序在执行的过程中所有的路径可以表示成树，叫做**执行树**。

如图 3-5，在代码中 test2 函数 总共存在 3 条执行路径，所以其可以组成了图 3-6 所示的执行树。

![image-20201225110227879](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201225110227879.png)

![image-20201225110246839](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201225110246839.png)

只要给出三组输入就可以遍历这三个路径，即图中每个路径中最终给出的 x 和 y 取值。当然**符号执行的目标也就是能够生成这样的输入集合，在给定的时间内探索所有的路径**。



为了能够满足符号执行的过程，符号执行会在执行的过程中**维护着两个全局的变量**。第一个就是当前符号的状态σ，第二个就是符号化的路径约束 PC，即在当前路径上对于每一个判断条件用符号化表达。在符号执行结束时，PC 就会利用当前的约束求解器（z3）进行求解，以生成实际的输入值。那么这个实际的输入值就可以完成当前路径的探索。

下面通过 3-5 中的程序代码进行详细的阐述。第 10 和第 11 行的读入代码会给变量 x，y 赋予符号量和。σ作为一个映射， 此时更新为σ → {x → x0,y → y0}。第 5 行代码的时候，此时符号状态更新为σ → {x → x0,y → y0，z → 2y0 }。

当程序遇到条件语句的时候，比如 if(e) S1 else S2，那么当前的 PC 会有两个更新。第一个是 PC 更新为 PC ∧ σ(e)，这表示走 if 分支；然后同时建立另外一个 路径约束 PC’，初始值为 PC ∧ ¬σ(e)，这表示走 else 分支。	**即像树那样去处理，树上一条分支上的约束都求完逆后或无解，说明这条分支就到叶了，再换到其他分支去执行。**

当符号执行的过程中出现了异常或者是错误，或约束无解，那么证明当前的路径是不可达的状态，所以也就不用继续进行探索。通过求解器的求解就会得到相应的输入，如果按照输入运行程序就会探索到对应的新路径。



### CFG和CG的识别

主要是识别一些特殊的指令和形式，包括对控制流的识别，调用流的识别以及具体系统 API 调用的识别。还需要图形化显示。

#### 控制流识别

控制流主要分为直接控制流和间接的控制流，在符号执行的过程中其实主要是识别具体的指令（jmp，jz等）。

记录控制流的信息一般要记录当前的 pc 值和将要跳转的 basic block 的首地址。具体保存格式如图 3-7。前面保存的是前一个 block 的末地址，后面保存的是其可能要跳转的地址。

![image-20201225115756495](%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE%E6%8F%90%E5%8F%96.assets/image-20201225115756495.png)





#### 调用流识别

对于调用流的识别，主要是识别指令中间的无条件跳转指令（jmp,call,ret）。同上，记录当前pc值和跳转block的首地址。



#### 系统API识别

分析 PE 文件主要找到 PE 文件头的位置，并对其进行解析，主要是对其中的输入表和输出表进行分析，得出其存在系统调用的位置和需要调用的方法。 输入表和输出表的位置在 PE 文件头中可选影响头字段中的数据目录表字段中，相对于 PE 文件标识处的偏移为+80h 和+78h 位置。

输入表可以理解成由数组组成的，一个程序要调用几个 dll 就会有几个对应的项，即每个项对应着一个 dll。所以根据输入表的内容就可以得出当前程序的系统调用。



